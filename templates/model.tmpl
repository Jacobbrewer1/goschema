package {{ .OutputDir | base | snakecase }}

// GENERATED BY GOSCHEMA. DO NOT EDIT.

import (
    "database/sql"
	"time"

	"github.com/go-sql-driver/mysql"
)
{{ with .Table }}
{{ $struct := .Name | structify }}
// {{ $struct }} represents a row from '{{ .Name }}'.
{{ if .Comment -}}// {{ .Comment }}{{- end -}}
type {{ $struct }} struct {
    {{- range $column := .Columns }}
    {{ if .Comment -}}// {{ .Comment }}{{- end -}}
    {{ .Name | structify }} {{ template "type" $column }} {{ template "tags" $column }}
    {{- end }}
}

{{ template "insert" . }}

{{ if has_primary_key . -}}
// IsPrimaryKeySet returns true if all primary key fields are set to none zero values
func (m *{{ $struct }}) IsPrimaryKeySet() bool {
    {{ range $column := .PrimaryKey.Columns -}}
    if !IsKeySet(m.{{ $column.Name | structify }}) {
        return false
    }
    {{ end }}
	return true
}
{{- end }}

{{ if identity_columns . -}}
{{ if non_identity_columns . -}}
{{ template "update" . }}
{{- end }}
{{- end }}

// Save saves the {{ $struct }} to the database.
func (m *{{ $struct }}) Save(db DB) error {
    {{ if identity_columns . -}}
    {{ if non_identity_columns . -}}
	if m.IsPrimaryKeySet() {
		return m.Update(db)
	}
    {{- end }}
    {{ end }}
	return m.Insert(db)
}

{{ template "delete" .}}

{{ range $key := unique_column_keys . }}
// {{ $struct }}By{{ range $i, $col := $key.Columns }}{{ $col.Name | structify }}{{ end }} retrieves a row from '{{ $.Table.Name }}' as a {{ $struct }}.
//
{{- $primary_key := contains "primary" $key.Type }}
{{- if $primary_key }}
// Generated from primary key.
{{- else }}
// Generated from index '{{ $key.Name }}' of type '{{ $key.Type }}'.
{{- end }}
{{- $unique_key := contains "unique" $key.Type }}
{{- $uniq := or $unique_key $primary_key }}
func {{ $struct }}By{{ range $col := $key.Columns }}{{ $col.Name | structify }}{{ end }}(db DB, {{ range $i, $col := $key.Columns }}{{ if $i }}, {{ end }}{{ $col.Name | structify | lcfirst }} {{ template "type" $col}}{{ end }}) ({{ if not $uniq }}[]{{ end }}*{{ $struct }}, error) {
    const sqlstr = "SELECT {{ range $i, $column := $.Table.Columns }}{{ if $i }},{{ end }}`{{ $column.Name }}`{{ end }} " +
        "FROM {{ $.Table.Name }} " +
        "WHERE {{ range $i, $col := $key.Columns }}{{ if $i }} AND {{ end }}`{{ $col.Name }}` = ?{{ end }}"

    DBLog(sqlstr, {{ range $i, $col := $key.Columns }}{{ if $i }}, {{ end }}{{ $col.Name | structify | lcfirst }}{{ end }})
    {{ if $uniq }}
    var m {{ $struct }}
    if err := db.QueryRow(sqlstr, {{ range $i, $col := $key.Columns }}{{ if $i }}, {{ end }}{{ $col.Name | structify | lcfirst }}{{ end }}).Scan({{ range $i, $col := $.Table.Columns }}{{ if $i }}, {{ end }}&m.{{ $col.Name | structify }}{{ end }}); err != nil {
		return nil, err
	}
    return &m, nil
    {{ else }}
    ret := make([]*{{ $struct }}, 0)
    rows, err := db.Query(sqlstr, {{ range $i, $col := $key.Columns }}{{ if $i }}, {{ end }}{{ $col.Name | structify | lcfirst }}{{ end }})
    if err != nil {
		return nil, err
	}
    defer rows.Close()

    for rows.Next() {
        var m {{ $struct }}
        if err := rows.Scan({{ range $i, $col := $.Table.Columns }}{{ if $i }}, {{ end }}&m.{{ $col.Name | structify }}{{ end }}); err != nil {
            return nil, err
        }
        ret = append(ret, &m)
    }

    return ret, rows.Err()
    {{ end }}
}

{{ end }}

{{- range $enumcol := enum_columns . }}
// Valid values for the '{{ $enumcol.Name | structify }}' enum column
var (
{{- range $enum := .Elements }}
    {{ $struct }}{{ $enumcol.Name | structify }}{{ $enum | structify }} = {{ if $enumcol.Nullable }}sql.NullString{Valid: true, String: "{{ $enum }}"}{{ else }}"{{ $enum }}"{{ end }}
{{- end }}
{{- if $enumcol.Nullable }}
    {{ $struct }}{{ $enumcol.Name | structify }}Null = sql.NullString{}
{{- end }}
)
{{ end }}

{{ end }}