// Package models contains the database interaction model code
//
// GENERATED BY GOSCHEMA. DO NOT EDIT.
package {{ .OutputDir | base | snakecase }}

import (
	"database/sql"
	"errors"
	"time"

	"github.com/go-sql-driver/mysql"
	"github.com/jacobbrewer1/patcher"
	"github.com/jacobbrewer1/patcher/inserter"
	"github.com/jacobbrewer1/goschema/usql"
	"github.com/prometheus/client_golang/prometheus"
)
{{ with .Table }}
{{ $struct := .Name | structify }}

const (
    // {{ $struct }}TableName is the name of the table for the {{ $struct }} model.
    {{ $struct }}TableName = "{{ .Name }}"
)

// {{ $struct }} represents a row from '{{ .Name }}'.
{{- if .Comment }}
// {{ .Comment }}
{{- end }}
type {{ $struct }} struct {
	{{ range $column := .Columns -}}
	{{ .Name | structify }} {{ get_type $column }} {{ get_tags $column }} {{ if .Comment }}// {{ .Comment }}{{ end }}
	{{ end -}}
}

{{ template "insert" . }}

{{ if has_primary_key . -}}
// IsPrimaryKeySet returns true if all primary key fields are set to none zero values
func (m *{{ $struct }}) IsPrimaryKeySet() bool {
	{{ $length := len .PrimaryKey.Columns -}}
	{{ if eq $length 1 -}}
	{{ $column := index .PrimaryKey.Columns 0 -}}
	return IsKeySet(m.{{ $column.Name | structify }})
	{{ else -}}
	return {{ range $i, $column := .PrimaryKey.Columns -}}{{ if $i }} && {{ end }}IsKeySet(m.{{ $column.Name | structify }}){{ end }}
	{{ end -}}
}
{{- end }}

{{ if identity_columns . -}}
{{ if non_identity_columns . -}}
{{ template "update" . }}

{{ template "insert_update" . }}
{{- end }}
{{- end }}

// Save saves the {{ $struct }} to the database.
func (m *{{ $struct }}) Save(db DB) error {
	{{ if identity_columns . -}}
	{{ if non_identity_columns . -}}
	if m.IsPrimaryKeySet() {
		return m.Update(db)
	}
	{{ end -}}
	{{ end -}}
	return m.Insert(db)
}

{{ if identity_columns . -}}
{{ if non_identity_columns . -}}
// SaveOrUpdate saves the {{ $struct }} to the database, but tries to update
// on unique constraint violations.
func (m *{{ $struct }}) SaveOrUpdate(db DB) error {
	{{ if identity_columns . -}}
	{{ if non_identity_columns . -}}
	if m.IsPrimaryKeySet() {
		return m.Update(db)
	}
	{{ end -}}
	{{ end -}}
	return m.InsertWithUpdate(db)
}
{{- end }}
{{- end }}

{{ template "delete" .}}

{{ range $key := unique_column_keys . }}
{{ $key_cnt := len $key.Columns }}
{{ $tbl_cnt := len $.Table.Columns }}
{{ if ne $key_cnt $tbl_cnt }}
{{ if eq $key.Type "primary" -}}
// {{ $struct }}By{{ range $i, $col := $key.Columns }}{{ $col.Name | structify }}{{ end }} retrieves a row from '{{ $.Table.Name }}' as a {{ $struct }}.
//
// Generated from primary key.
func {{ $struct }}By{{ range $i, $col := $key.Columns }}{{ $col.Name | structify }}{{ end }}(db DB, {{ range $i, $col := $key.Columns }}{{ if $i }}, {{ end }}{{ $col.Name | structify | lcfirst }} {{ get_type $col}}{{ end }}) (*{{ $struct }}, error) {
    t := prometheus.NewTimer(DatabaseLatency.WithLabelValues("get_" + {{ $struct | structify }}TableName + "_by_{{ range $i, $col := $key.Columns }}{{ $col.Name | lcfirst }}{{ end }}"))
    defer t.ObserveDuration()

	const sqlstr = "SELECT {{ range $i, $column := $.Table.Columns }}{{ if $i }}, {{ end }}`{{ $column.Name }}`{{ end }} " +
		"FROM {{ $.Table.Name }} " +
		"WHERE {{ range $i, $col := $key.Columns }}{{ if $i }} AND {{ end }}`{{ $col.Name }}` = ?{{ end }}"

	DBLog(sqlstr, {{ range $i, $col := $key.Columns }}{{ if $i }}, {{ end }}{{ $col.Name | structify | lcfirst }}{{ end }})
	var m {{ $struct }}
	if err := db.Get(&m, sqlstr, {{ range $i, $col := $key.Columns }}{{ if $i }}, {{ end }}{{ $col.Name | structify | lcfirst }}{{ end }}); err != nil {
		return nil, err
	}

	return &m, nil
}

type {{ lcfirst $struct }}PKWherer struct {
    ids []interface{}
}

func (m {{ lcfirst $struct }}PKWherer) Where() (string, []interface{}) {
    return "{{ range $i, $col := $key.Columns }}{{ if $i }} AND {{ end }}`{{ $col.Name }}` = ?{{ end }}", m.ids
}

// Patch updates the {{ $struct }} in the database.
//
// Generated from primary key.
func (m *{{ $struct }}) Patch(db DB, newT *{{ $struct }}) error {
    if newT == nil {
        return errors.New("new {{ .Name }} is nil")
    }

    t := prometheus.NewTimer(DatabaseLatency.WithLabelValues("patch_" + {{ $struct }}TableName))
    defer t.ObserveDuration()

	res, err := patcher.NewDiffSQLPatch(
	    m,
	    newT,
	    patcher.WithTable({{ $struct }}TableName),
	    patcher.WithWhere(&{{ lcfirst $struct }}PKWherer{
	        ids: []interface{}{ {{ range $i, $col := $key.Columns }}m.{{ $col.Name | structify }},{{ end }} },
	    }),
	)
	if err != nil {
		switch {
    	case errors.Is(err, patcher.ErrNoChanges):
    		return nil
    	default:
    		return fmt.Errorf("new diff sql patch: %w", err)
    	}
	}

	sqlstr, args, err := res.GenerateSQL()
	if err != nil {
	    return fmt.Errorf("failed to generate patch: %w", err)
	}

	DBLog(sqlstr, args...)
	_, err = db.Exec(sqlstr, args...)
	if err != nil {
		return fmt.Errorf("failed to execute patch: %w", err)
	}

	return nil
}
{{ range $constraint := $.Table.Constraints -}}
{{ $constraint_ref_len := len $constraint.References }}
{{ if eq $constraint_ref_len 1 -}}
{{ $foreign_struct := $constraint.ReferenceTable | structify }}
{{ range $i, $col_data := $.Table.Columns -}}
{{ range $local_col, $foreign_col := $constraint.References -}}
{{ if eq $col_data.Name $local_col -}}
// Get{{ $local_col | structify }}{{ $foreign_struct }} Gets an instance of {{ $foreign_struct }}
//
// Generated from constraint {{ $constraint.Name }}
func (m *{{ $struct }}) Get{{ $local_col | structify }}{{ $foreign_struct }}(db DB) (*{{ $foreign_struct }}, error) {
  {{ if $col_data.Nullable -}}
  if !m.{{ $local_col | structify }}.Valid {
    return nil, nil
  }

  {{ end -}}
	return {{ $foreign_struct }}By{{ $foreign_col | structify }}(db, m.{{ $local_col | structify }}{{ if $col_data.Nullable }}.{{ get_type $col_data }}{{ end }})
}
{{ end -}}
{{ end -}}
{{ end -}}
{{- end }}
{{- end }}

{{- else -}}
{{- $uniq := contains "unique" $key.Type }}
{{- if $uniq }}
// {{ $struct }}By{{ range $i, $col := $key.Columns }}{{ $col.Name | structify }}{{ end }} retrieves {{ if $uniq }}a row{{ else }}rows{{ end }} from '{{ $.Table.Name }}' as a {{ if $uniq }}*{{ $struct }}{{ else }}[]*{{ $struct }}{{ end }}.
//
// Generated from index '{{ $key.Name }}' of type '{{ $key.Type }}'.
func {{ $struct }}By{{ range $i, $col := $key.Columns }}{{ $col.Name | structify }}{{ end }}(db DB, {{ range $i, $col := $key.Columns }}{{ if $i }}, {{ end }}{{ $col.Name | structify | lcfirst }} {{ get_type $col}}{{ end }}) ({{ if not $uniq }}[]{{ end }}*{{ $struct }}, error) {
    t := prometheus.NewTimer(DatabaseLatency.WithLabelValues("get_" + {{ $struct | structify }}TableName + "_by_{{ range $i, $col := $key.Columns }}{{ $col.Name | lcfirst }}{{ end }}"))
    defer t.ObserveDuration()

	const sqlstr = "SELECT {{ range $i, $column := $.Table.Columns }}{{ if $i }}, {{ end }}`{{ $column.Name }}`{{ end }} " +
		"FROM {{ $.Table.Name }} " +
		"WHERE {{ range $i, $col := $key.Columns }}{{ if $i }} AND {{ end }}`{{ $col.Name }}` = ?{{ end }}"

	DBLog(sqlstr, {{ range $i, $col := $key.Columns }}{{ if $i }}, {{ end }}{{ $col.Name | structify | lcfirst }}{{ end }})
	var m {{ if not $uniq }}[]*{{ end }}{{ $struct }}
	if err := db.{{ if $uniq }}Get{{ else }}Select{{ end }}(&m, sqlstr, {{ range $i, $col := $key.Columns }}{{ if $i }}, {{ end }}{{ $col.Name | structify | lcfirst }}{{ end }}); err != nil {
		return nil, err
	}

	return {{ if $uniq }}&{{ end }}m, nil
}
{{ end }}
{{ end }}
{{ end }}
{{ end }}

// GetAll{{ $struct }} retrieves all rows from '{{ .Name }}' as a slice of {{ $struct }}.
//
// Generated from table '{{ .Name }}'.
func GetAll{{ $struct }}(db DB) ([]*{{ $struct }}, error) {
    t := prometheus.NewTimer(DatabaseLatency.WithLabelValues("get_all_" + {{ $struct | structify }}TableName))
    defer t.ObserveDuration()

    const sqlstr = "SELECT {{ range $i, $column := $.Table.Columns }}{{ if $i }}, {{ end }}`{{ $column.Name }}`{{ end }} " +
        "FROM {{ $.Table.Name }}"

    DBLog(sqlstr)
    m := make([]*{{ $struct }}, 0)
    if err := db.Select(&m, sqlstr); err != nil {
        return nil, fmt.Errorf("failed to get all {{ $struct }}: %w", err)
    }

    return m, nil
}

{{- range $enumcol := enum_columns . }}
// Valid values for the '{{ $enumcol.Name | structify }}' enum column
var (
{{- range $enum := .Elements }}
	{{ $struct }}{{ $enumcol.Name | structify }}{{ $enum | structify }} = {{ if $enumcol.Nullable }}usql.NewNullEnum("{{ $enum }}"){{ else }}usql.NewEnum("{{ $enum }}"){{ end }}
{{- end }}
{{- if $enumcol.Nullable }}
	{{ $struct }}{{ $enumcol.Name | structify }}Null = usql.NullEnum{}
{{- end }}
)
{{ end }}

{{ end }}
